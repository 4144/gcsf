\chapter{Proposed approach}

\section{Aim}

This project aims to improve the experience of using Google Drive specifically for power users. Regular users can benefit from it as well -- provided they follow some prerequisite steps in order to use the application.

If successful, it will drastically diminish the issues described in \ref{power_user_experience}.

\section{Summary}

In essence, Google Drive is nothing more than a remote storage system. All the operations that a user might want to execute on a local storage system (e.g. copying files, creating and organising directories, reading and writing data) have an equivalent operation on Google Drive.

Disk-based storage devices are organized by the operating system using a filesystem in order to keep track of all the data they contain. This happens behind the scences. Users can interact with the storage device using system calls. Some of the more popular ones are \codeword{read}, \codeword{write}, \codeword{close}, \codeword{wait}, \codeword{exec}, \codeword{fork}, \codeword{exit}, \codeword{kill}. Note that not all of these deal with file storage. Some of them are a proxy which expose different functionalities of the operating system.

An interesing concept comes to mind: why not model a Google Drive account in such a way that it behaves identically to a traditional filesystem? The only difference would be that instead of storing and reading data from a local disk, it would interact with Google's servers.

\section{GCSF}

GCSF does exactly that. It is a virtual filesystem on top of Google Drive. It allows users to mount their Drive account locally and interact with it as with a regular disk partition. This is achieved using the FUSE (Filesystem in Userspace) interface\footnote{\url{https://github.com/libfuse/libfuse}}, as described in \ref{implementation}.

\section{Implementation} \label{implementation}

\subsection{FUSE}

FUSE (\textbf{F}ilesystem in \textbf{Use}rspace) is a project that allows users to create virtual filesystems in the user level. Internally, it delegates tasks to a kernel module. As so, users do not have to interact with the kernel directly. FUSE is a popular choice for esoteric filesystems which do not store data themselves. A few notable examples are \emph{sshfs}\footnote{\url{https://github.com/libfuse/sshfs}}, which mounts a remote filesystem using SFTP\footnote{\url{https://tools.ietf.org/html/draft-moonesamy-secsh-filexfer-00}}, and \emph{WikipediaFS}\footnote{\url{http://wikipediafs.sourceforge.net/}} which allows users to view and edit articles locally.

FUSE is made up of two components:
\begin{itemize}
  \item the \textit{fuse} kernel module
  \item the \textit{libfuse} userspace library
\end{itemize}

FUSE filesystems are usually implemented as regular applications that interact with the \textit{libfuse} library. This library provides two interfaces that are useful for defining the behavior of the filesystem. In both cases, the filesystem receives incoming requests from the kernel, which are provided as calls to methods defined in the interface.

First, there is the high-level interface. It uses high-level concepts such as file names and paths in most of its methods. Second, there is the low-level interface. Files are identified using low level concepts such as inodes\cite{tanenbaum}. GCSF uses the latter because of the available language library for Rust.

\subsubsection{High-level interface}

\lstinputlisting[language=C, caption=High-level FUSE interface, frame=single]{fuse.h}

\subsubsection{Low-level interface}
\lstinputlisting[language=C, caption=Low-level FUSE interface, frame=single]{fuse_lowlevel.h}

\subsection{Rust client library}

A Rust implementation of the original FUSE library is available through the \emph{fuse}\footnote{\url{https://crates.io/crates/fuse}} crate. GCSF implements the \codeword{Filesystem} trait defined below.

\lstinputlisting[language=Rust, caption=Rust FUSE interface, frame=single]{fuse.rs}
